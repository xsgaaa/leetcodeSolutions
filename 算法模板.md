# 算法模板

## 1.Dijkstra算法

### 模板题：[743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

朴素版

```cpp
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);	//初始化所有距离为0x3f3f3f3f
    dist[1] = 0;						//起点的距离置为0	
    for (int i = 1; i <= n; i ++ )		//遍历n次
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
		if(t==-1)	break;	//没有最短距离，退出
        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

堆优化版

```cpp
int networkDelayTime(vector<vector<int>>& times, int N, int K) {
        unordered_map<int,vector<PII>> g;
        for(auto & t:times)
        {
            g[t[0]].push_back({t[1],t[2]});
        }
        int dist[N+1];
        memset(dist,0x3f,sizeof dist);
        bool st[N+1];
        memset(st,0,sizeof st);
        priority_queue<PII,vector<PII>,greater<PII>> pq;
        pq.push({0,K});
        dist[K]=0;
        while(!pq.empty())
        {
            auto t=pq.top();
            pq.pop();
            int ver=t.y,distanse=t.x;
            if(st[ver]) continue;
            st[ver]=true;
            for(auto & p:g[ver])
            {
                if(p.y+distanse<dist[p.x])
                {
                    dist[p.x]=p.y+distanse;
                    pq.push({dist[p.x],p.x});
                }
            }
        }
        int ans=*max_element(dist+1,dist+N+1);
        return ans==0x3f3f3f3f?-1:ans;
    }
```

## 2.KMP算法

#### 模板题：[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

```cpp
//注意:两个字符串的起始位置都是从1开始的。
int ne[n];
memset(ne,0,sizeof ne);

for(int i=2,j=0;i<n;i++)
{//计算next数组
    while(j && p[i]!=p[j+1]) j=ne[j];
    if(p[i]==p[j+1]) j++;
    ne[i]=j;
}

int idx=-1;
for(int i=1,j=0;i<m;i++)
{//匹配S串
    while(j && s[i]!=p[j+1]) j=ne[j];
    if(s[i]==p[j+1])    j++;
    if(j==n-1)
    {
        idx=i;
        break;
    }
}
```



## 3.并查集

#### 模板题：[684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

```cpp
//一般来说，朴素的就够用了。
(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
(2)维护size的并查集：

    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
(3)维护到祖宗节点距离的并查集：

    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

