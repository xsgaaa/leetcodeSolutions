# 易错题

#### 1.以下哪个Linux命令可以一次显示一页内容？

> 答案：more.

> 解析：
>
> cat 是把内容全部显示出来 
>
> more是显示一页 

#### 2.在系统内存中设置磁盘缓冲区的主要目的是

> 答案：为了弥补CPU和IO外设之间的速度差。减少磁盘 I/O 次数

#### 3.下面哪种存储器，存取周期最短

> 答案：**内存。**

> 解析：
>
> 内存是计算机写入和读取数据的中转站，它的速度是最快的。
>
> 存取周期最短的是内存，其次是硬盘，再次是光盘，最慢的是软盘。

#### 4.数组A为有18个元素的有序数组，第一个元素放A[1]中，现进行二分查找，则查找A[3]时需要访问的数组下标依次为

> 答案：**9，4，2，3**

> 解析：
>
> 每次取mid值：**mid = left + (right - left) / 2** ，并且不断更新left和right值，如果在mid左边right=mid-1，如果在mid右边left=mid+1
>
> 第一次：left：1，right：18，mid：1+(18-1)/2=9
>
> right->mid-1
>
> 第二次：left：1，right：9-1=8，mid：1+(8-1)/2=4
>
> right->mid-1
>
> 第三次：left：1，right：4-1=3，mid：1+(3-1)/2=2
>
> left->mid+1
>
> 第四次：left：2+1=3，right=3，mid=3

#### 5.判断有向图是否存在回路，利用()方法最佳

> 答案：**拓扑排序**

#### 6.以下哪个排序的平均速度最快？

> 答案：**快速排序**

> 解析：
>
> shell排序的平均复杂度是O(nlogn)~O(n^2)，最好的情况O(n^1.3)，最坏的情况O(n^2)
>
> 快速排序的平均复杂度是O(nlogn)，      最好的情况O(nlogn)，最坏的情况O(n^2)
>
> 直接插入排序的平均复杂度是O(n^2)，     最好的情况O(n)，    最坏的情况O(n^2)
>
> 冒泡排序的平均复杂度是O(n^2),          最好的情况O(n),     最坏的情况O(n^2)

#### 7.下面关于JAVA继承的描述正确的是

> 答案：只允许单一继承

> 解析：
>
> 单继承，多接口。
>
> 参考：https://blog.csdn.net/xujiangdong1992/article/details/76812189

#### 8.下列关于修饰符混用的说法，错误的是

```
A.abstract不能与final并列修饰同一个类
B.abstract类中可以有private的成员
C.abstract方法必须在abstract类中
D.static方法中能处理非static的属性
```

> 答案：D

> 解析：
>
> 静态方法不能处理非静态属性 D错
>
> 抽象类可以被继承 final类不能被继承 A对
>
> 抽象类中成员访问修饰符没限制 B对
>
> 抽象类中可以无抽象方法 有抽象方法一定是抽象类 C对
>
> 参考：https://www.runoob.com/java/java-abstraction.html

#### 9.从以下哪一个选项中可以获得Servlet的初始化参数

> 答案：ServletConfig

> 解析：
>
> servletContext上下文对象，全局程序共享
>
> servletConfig 用于加载Servlet的初始化参数
>
> 最后一个不太清楚，顺便帮你们查了：GenericServlet 是Servlet接口的 实现类，我们可以继承GenericServlet来编写自己的Servlet

#### 10.进程进入等待状态有哪几种方式

> 答案：获得spinlock未果

> 解析：
>
> 进程分为基本的三个状态：运行、就绪、阻塞/等待。
>
> A. 高优先级的抢占CPU，使得原来处于运行状态的进程转变为就绪状态。
>
> B. 阻塞的进程等待某件事情的发生，一旦发生则它的运行条件已经满足，从阻塞进入就绪状态。
> C. 时间片轮转使得每个进程都有一小片时间来获得CPU运行，当时间片到时从运行状态变为就绪状态。
>
> D. 自旋锁（spinlock）是一种保护临界区最常见的技术。在同一时刻只能有一个进程获得自旋锁，其他企图获得自旋锁的任何进程将一直进行尝试（即自旋，不断地测试变量），除此以外不能做任何事情。因此没有获得自旋锁的进程在获取锁之前处于忙等（阻塞状态）。

#### 11.编译过程中，语法分析器的任务是

> 答案：根据构词规则识别单词

> 解析：
>
> 词法分析器：分析单词的构成 （class, const , static）
>
> 语法分析器：一个句子的构成。（单词组合）
>
> 语义分析器：判断程序的结构。

#### 12.数据库操作中，当关系S自然联接时，能够把S本该舍弃的元组放到结果关系中的操作是

> 答案：外联接

> 解析：
>
> 外连接：通常的连接操作中，只有满足连接条件的元组才能作为结果输出。
>
> 如果 想要列出表中每个元组观察状态，即便某条记录不满足条件，在属性上填Null,需要用外连接。

#### 13. SELECT语句中与HAVING子句通常同时使用什么语句

> 答案：GROUP BY

#### 14.下面关于UPDATE语句的说法正确的是

```cpp
A.通过它可以修改数据库表的列名与数据类型
B.通过它只能修改数据库表的列名 
C.通过它可以一次修改表中所有的行
D.通过它不能一次修改表中所有的行
```

> 答案：通过它可以一次修改表中所有的行。选C。

#### 15.同一个关系模型的任两个元组值

> 答案：不能全同。

#### 16.某网络的IP地址空间为192.168.5.0/24，采用定长子网划分，子网掩码为255.255.255.248，则该网络的最大子网个数、每个子网内最大可分配地址个数？

> 答案：32,6
>
> 解析：
>
> 248是11111 000
>
> 前面5个1划分32个子网
>
> 3个0划分8个主机 去掉000和111 就是6个

#### 17.下列协议中，把MAC地址映射成IP地址的是

> 答案：RARP

> 解析：
>
> ARP 地址解析 IP到MAC
>
> MAC到IP  RARP 逆地址解析协议

#### 18. 某台计算机连接了8个相同的设备，有N个进程在竞争使用，每个进程最多会同时占用3个设备，请问当N大于等于多少时，系统可能发生死锁？

> 答案：4
>
> 解析：
>
> 每个进程3台，不会产生死锁；对于三个进程，可以有两个进程分别获得3台，使其执行完释放后让第三个进程获得3台，所以也不会产生死锁；对于四个进程，假若每个进程各获得2台而同时需要另外一台，产生了死锁，所以产生死锁的最小值是4。
> 类似题型(1)：假设现在有P个进程，每个进程最多需要m个资源，并且有r个资源可用。什么样的条件可以保证死锁不会发生
> 解：如果一个进程有m个资源它就能够结束，不会使自己陷入死锁中。因此最差情况是每个进程有m-1个资源并且需要另外一个资源。如果留下有一个资源可用，那么其中某个进程就能够结束并释放它的所有资源．使其它进程也能够结束。所以避免死锁的条件是：
> r≥p(m-1)+1。
> 由此条件解上题：r=8，m=3，带入公式得：2p≤7。即当P小于等于3时才可保证死锁不会发生，所以可能会产生死锁的最小值是4。
> 类似题型(2)：某系统中有3个并发进程，都需要同类资源4个，试问该系统不会发生死锁的最少资源数是多少
>
> 解：带入上述条件公式：r≥3*(4-1)+1=10。所以答案为10个。 

#### 19.如果想列出当前目录以及子目录下所有扩展名为“.txt”的文件，那么可以使用以下哪个命令？

```shell
答案：find . -name "*.txt"
```

> 解析：
>
> ```
> ls *.txt 只能显示本目录下的txt文件名
> ```

#### 20.以下哪一项不是c++11 新引入的容器

> 答案：std::map

> 解析：
>
> C++新添加的容器：详细可参考https://www.cnblogs.com/xenny/p/9689784.html
>
> - unordered_map
> - unordered_set
> - unordered_multimap
> - unordered_multiset
> - array
> - forward_list
> - tuple

#### 22.使用gcc编译一份C代码的过程，报错提示"undefined reference to 'XXXXX'"，这是哪个阶段出错了？

> 答案：链接

> 解析：参考：https://zhuanlan.zhihu.com/p/81681440

#### 23.访问主存上的数据，大概需要多少个机器时钟？

> 答案：100

#### 24.以下哪一项不会导致C程序发生“段错误”？

> 答案：忘记释放已分配的内存块

> 解析：段错误：指访问的内存超出了系统所给这个程序的内存空间。

#### 25.“定义了一系列算法，并将每个算法封装起来，使它们可以相互替换”是指以下哪种设计模式？

> 答案：策略模式

> 解析：在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。
>
> 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法

#### 26.2019! 的末尾有多少个零？

> 答案：502

> 解析：
>
> 2019！=1*2*3*4*5*......*2019 ——什么时候会计算结果的末尾增加0？2*5，10,15*2也就是5的倍数乘一个偶数时（10的倍数自带0），其中25*4x又会加两个0，125*8x会加三个0，5，25，125又分别有1,2,3,个因子五.即0的数量取决于共有多少个因子5（例如：50=5*5*2有两个因子5）
>
> 2019/5=403,有403个数至少有一个因子5，可以和偶数凑0
>
> 在这403个数中
>
> 403/5=80有80个数有两个因子5，即可以跟偶数再凑一个0
>
> 依次类推
>
> 80/5=16 
>
> 16/5=3
>
> 403+80+76+3=502
>
> 可以凑502个数

#### 27.虚拟内存的容量只受()的限制

> 答案：计算机地址位数

> 解析：虚拟内存的容量只守计算机地址位数的影响。

#### 28.按照二叉树的定义,具有3个结点的二叉树有几种。

> 答案：5

> 解析：
>
> Catalan数，h(n)=C(2n,n)/(n+1).
>
> C(2n,n)即常见组合问题，从2n个数中随机抽取n个
>
> 此处n=3,h(3)=C(6,3)/(3+1)=20/4=5

#### 29.个叶子节点的完全二叉树, 最多有几个结点（）

> 答案：448

> 解析：
>
> ```cpp
> /*
> 二叉树具有性质：
> 1、度为0的结点个数=度为2的结点个数+1，即n0=n2+1（其中n0表示度为0的结点个数，n2表示度为2的结点个数）。注 ：二叉树的度代表某个结点的孩子或者说直接后继的个数。
> 2、完全二叉树中度为1的结点个数要么0个，要么1个。
> 3、二叉树结点个数n=n0+n1+n2
> */
> ```
>
> 综合性质，结合题目有 n0=224，故224=n2+1，得n2=224-1=223。
>
> 当为度0的结点存在时，结点总数为n=n0+n1+n2=224+0+223=447。
>
> 当为度1的结点存在时，结点总数为n=n0+n1+n2=224+1+223=448。
>
> 故最多为448个，选B

#### 30. UDP报头中没有下面那些信息:() 

```cpp
A.目的地址
B.窗口大小
C.序列号
D.检验和
```

> 答案：ABC

> 解析：UDP报文段结构：源端口号，目的端口号，长度，检验和，应用数据

#### 31.无限多水源 一个4L无刻度桶, 一个9L无刻度桶, 那么只利用这两个桶, 可以获得的水量有()

```
A.1
B.5
C.8
D.11
```

> 答案：ABCD

> 解析：
>
> 参考这题：[https://leetcode-cn.com/problems/water-and-jug-problem/.](https://leetcode-cn.com/problems/water-and-jug-problem/)
>
> 只要 x,y 均为整数，且满足4x+9y=z成立的z都可以作为结果。
>
> 题中:
>
> 4*(-2)+9*1=1，A项对。
>
> 4*(-1)+9*1=5，B项对
>
> 4*2+9*0=8，C项对
>
> 4*5+9*(-1)=11，D项对

#### 32. 散列表中解决冲突的方法有（） 

```
A.平方取中法
B.除留余数法
C.再散列法
D.开放寻址法
```

> 答案：CD

> 解析：
>
> 平方取中法和除数留余法属于哈希函数，另外还有直接定址法和随机数法，而解决哈希冲突的方法有，开放地址法（再哈希，二次探测、线性探测）和常用的链地址法

#### 33.下面关于数据库索引的描述正确的有（）

```
A.唯一索引列允许空值；
B.使用in查询，联合索引不生效；
C. MySQL的索引能使用B+树或hash实现；
D.查询条件的顺序不会影响联合索引的生效；
```

> 答案：ACD

> 索引是否生效主要取决于字段类型：
>
> 1. 如果字段类型为字符串，需要给in查询中的数值与字符串值都需要添加引号，索引才能起作用。
> 2. 如果字段类型为int，则in查询中的值不需要添加引号，索引也会起叙用。
> IN的字段，在联合索引中，按以上方法，也会起作用。
> 3. mysql查询优化器认为全表扫描时如果速度大于使用索引，就会不用索引，你可以使用FORCE INDEX强制mysql使用索引

#### 34.假如一个作业的页面走向是:1,2,3,4,2,1,5,2,1。当内存块数量为3时,请问LRU,FIFO这两种置换算法的缺页次数各是多少? () 

```
答案：6,7
```

#### 某进程页面访问序列为1、2、3、1、4、2，且开始执行时内存中没有页面，分配给该进程的物理块数为3，则采用FIFO页面置换算法和LRU页面置换算法时，缺页率分别为：

```cpp
答案:83%和67%
```

#### 35.以下关于sql查询语句执行顺序描述正确的是：（）

```sql
A.select->from->where->group by→having→order by
B.from->where->select->group by→having→order by
C.from->where->group by→having→select→order by
D.select->from->group by→having→where→order by
```

> 答案：C
>
> 注意题中说的是执行顺序。A选项是语法的书写顺序，C选项才是语法的执行顺序。
>
> 语法的执行顺序如下：
>
> (1) FROM <left_table>
>
> (2) ON <join_condition>
>
> (3) <join_type> JOIN <right_table>
>
> (4) WHERE <where_condition>
>
> (5) GROUP BY <group_by_list>
>
> (6) HAVING <having_condition>
>
> (7) SELECT
>
> (8) DISTINCT <select_list>
>
> (9) ORDER BY <order_by_condition>
>
> (10) LIMIT <limit_number>
>
> 标号为执行顺序

#### 36.一位老师有2个推理能力很强的学生，他告诉学生他手里有以下的牌： 

> 黑桃：2 ， 5 ， 7 ， 9 ， J ， K
> 红心：3 ， 4 ， 9 ， J ， K
> 梅花：5 ， 8 ， 9 ， Q
> 方块：2 ， 7 ， 8
> 然后从中拿出一张牌，告诉A这张牌的大小，告诉了B这张牌的花色；
> A：我不知道这张是什么牌
> B：我就知道你肯定不知道这张是什么牌
> A：现在我知道
> B：现在我也知道了
> 请问这张是什么牌？（）

> 答案：方块8

> 解析：
>
> 由第一个条件可知，这个数字必须出现两种以上花色；
>
> 由第二个条件可知，这种花色的所有数字必须出现两次以上，所以排除红心、梅花，只剩黑桃和方块；
>
> 由第三个条件可知，这个数字在黑桃和方块仅出现一次；
>
> 由第四个条件可知，这种花色里符合以上条件的数字唯一，所以排除黑桃，只剩方块8；

#### 37.下列排序算法在最好情况下的时间复杂度为O(n)的是()

```
A.堆排序
B.快速排序
C.冒泡排序 
D.插入排序
E.桶排序 
```

```
答案:CDE
```

#### 38.如果一个二叉树的先序遍历是：DCAGFEB，那么它的中序遍历可能是：()

```
A.ACGDEFB
B.CDFGEAB
C.DCGAFEB
D.CGAFDEB
```

```
答案:ABCD
```

#### 39.Dijkstra算法按照长度递增的方式求无向图中单源点的最短路路径问题。该算法运用了以下哪种策略：

```cpp
答案：贪心。
```

#### 40.电子邮件应用程序应用POP3协议完成以下哪项工作： 

```
答案:接收邮件
```

```cpp
SMTP是发送协议，POP3是读取协议
SMTP协议的应用范围：发件人-->发送方服务器-->接收方服务器，这个通信过程通过 TCP连接 完成
POP3的应用范围：接收方服务器-->收件人，这个通信的过程同样是 靠TCP连接 完成
```

#### 41.已知信号量的初值为2，当前值为-3，则表示有多少个等待进程：

```
A.1
B.2
C.3
D.5
```

```cpp
答案:选C，如何信号量为负，则它的绝对值就是等待它的进程数
```

#### 42.设G是一个具有36条边、不含自回路和多重边的非连通无向图，则G最少有多少个顶点：

```cpp
A.8
B.9
C.10
D.11
```

```
答案：C，n(n-1)/2=72,解的n=9，因为是非连通的，所以再加一个顶点答案为10
```

#### 43. 在进程状态转换时，以下不可能发生的是：

```cpp
A.等待态 --> 运行态
B.运行态 --> 就绪态
C.运行态 --> 等待态
D.就绪态 --> 运行态
```

```
答案：看下图
```

![43](picture\43.png)

#### 44. 74LS283是一款四位全加器数字芯片，其输入为2路4位的数字信号A和B，输出为一路5位（含进位）的数字信号C，满足C=A+B。在只有一块74LS283没有其他数字芯片的情况下，对一路3位数字信号X，以下说法中错误的是：

```cpp
答案：可以实现Y=X*7的电路
```

```cpp
解析：
X*3 = X*2 + X = X << 1 + X
X*5 = X*4 + X = X << 2 + X
X*9 = X*8 + X = X << 3 + X
X*7 不能改成两个的和

左移不需要加法器 直接低位补0就行
```

#### 45. 有向图D的邻接矩阵为：

![img](https://www.nowcoder.com/equation?tex=%5Cbegin%7Bpmatrix%7D%0A1%261%260%5C%5C%0A0%260%261%5C%5C%0A1%260%260%5C%5C%0A%5Cend%7Bpmatrix%7D)

#### 则D中长度为3的通路共有多少条？

```
解析：
邻接矩阵的k次幂即可以表示图中任意两节点间长度为k的路径的数量
原矩阵3次方之后为[2 1 1
               1 1 0
               1 1 1],相加之后等于9 
```

# 排序

#### 关于快速排序，下列说法正确的有（）

> ```
> A.快速排序是基于比较的排序
> B.快速排序使用了分治的思想
> C.在某些特殊数据中，快速排序的时间复杂度可以达到O(n)
> D.快速排序只能使用递归方式实现
> ```

> 解析：AB
>
> D项，快排可以用非递归的方式实现

# 数据库

#### 有一个名为app的MySQL数据库表，其建表语句如下：

```sql
CREATE TABLE `app` (
`app_id` int(10) DEFAULT '0',//应用ID
`version_code` int(10) DEFAULT '0',//应用的版本号
`download_count` int(10) DEFAULT '0'//当前版本的下载量
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
```

> 当前表中数据记录如下，一条记录表示某个应用的某个版本的下载量记录：
> 问： 下面那个MySQL语句可以查出每个应用中总下载量最大的版本号和次数（ ）？

```sql
答案：
select t.app_id, t.version_code, max(t.download_sum) from (select app_id, version_code, sum(download_count) download_sum from app
group by app_id, version_code order by download_sum desc) as t group by t.app_id;
```

> 解析：
>
> 1，先按照哪个应用的具体哪个版本分好类，from app group by app_id, version_code；
>
> 2，然后取出id，版本号，最关键的是按照聚类累加一下下载量并对其重命名，select app_id, version_code, sum(download_count) download_sum from app group by app_id, version_code；
>
> 3，之后对选出的数据按照下载量降序排序处理；select app_id, version_code, sum(download_count) download_sum from app group by app_id, version_code order by download_sum desc；
>
> 4，题目要求:**每个应用中**总下载量最大的版本号和次数，那么对整理后的新表重命名并按照应用id进行分类，(select app_id, version_code, sum(download_count) download_sum from app group by app_id, version_code order by download_sum desc) as t group by t.app_id
>
> 5，选出每一类（也就是每一个应用）中最大下载量的数据表信息。

#### 关于数据库的描述正确的是（）

> ```
> A. 如果数据Ａ持有某事务的排它锁，那么其它事务对数据A，加共享锁、加排它锁都失败
> B. 一个多对多的关系的表，可通过一个中间表分为两个一对多的关系的表
> C. sql中关键字delete可以删除表中数据，但不能直接删除表
> D. 主键最为一条记录的唯一标识，不能有重复，但允许为空
> ```

> 答案：ABC
>
> 解析：
>
> 1.drop table table_name 用来删除表
>
> 2.主键用于唯一标识一条记录，不能重复，不允许为空

# 设计模式

#### 不同级别的用户对同一对象拥有不同的访问权利或某个客户端不能直接操作到某个对象，但又必须和那个对象有所互动，这种情况最好使用什么设计模式。（）

> ```
> A.Bridge模式
> B.Factory模式
> C.Adapter模式
> D.Proxy模式
> ```

> 答案：D代理模式。
>
> 解析：

#### 当已有类能满足目前的需求但和当前的系统兼容性比较差的情况下，比较适合使用（ ）

```
工厂模式
适配器模式
装饰器模式
代理模式
```

> 解析：B
>
> 适配器模式（Adapter）通常适用于以下场景。
>
> - 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
> - 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

# 计算机网络

#### 32位的ip地址3232238233转换为字符串的Ip地址正确的是（）

> ```
> A. 192.168.32.132
> B. 192.168.40.150
> C. 192.168.10.14
> D. 192.168.10.153
> ```

> 答案：选D。
>
> **这个目的应该不是考硬算的**
>
> 最后一位是3所以 转换后最后应该是个奇数d是153选d
>
> 
>
> 3232238233转化为二进制110000001010100000001010 10011001
>
> 有32位分成4个八位：11000000 10101000 00001010 10011001
>
> 转化为二进：192.168.10.153

# 数据结构

#### 下列关于一颗深度为K，具有n个节点二叉树的下列诉述正确的是（）

> ```
> A. 在这个二叉树的第i(i>=1)层最多有2^(i-1)个节点
> B. 这个二叉树最多有(2^k)-1个节点
> C. 这个二叉树最少有2^(k-1)个节点
> D. 在完全二叉树中，这个二叉树的深度为[log n]-1
> ```

> 答案：A B  
>
> 解析：当树为完全二叉树时，A B均满足要求。

#### 关于堆数据结构，下面描述中正确的有（）

```
A.可以用堆实现优先队列（priority_queue）
B.使用堆可以实现排序算法，复杂度为N * log N
C.从M个元素中查找最小的N个元素时，使用大顶堆的效率比使用小顶堆更高
D.在大顶堆中，第N层中的所有元素比第N+1层中的所有元素都要大
E.堆数据结构可以用数组方式存储，存储的是一棵完全二叉树
```

> 解析：ABCE
>
> **小顶堆思路**：构建一个容量为n的堆，建堆时间为n，此后每次都弹出堆顶元素（最小元素）再调整，一共弹 K 次，每次调整时间为log(n)，所以时间复杂度是 n+K*log(n)；
>
> **大顶堆思路**：只维护一个容量为 K 的堆，所以建堆的复杂度为 K，此后遍历数组剩下的所有元素（n-K个），每个元素都要和堆顶的元素进行比较，如果比堆顶大，则忽略（说明该元素不是最小K个值，概率比较难算，这里简单当作(n-K)/n），复杂度是1，如果比堆顶小（概率简单视作K/n），则将堆顶替换为该元素并调整堆结构（称之为堆更新），每次更新（堆调整）的复杂度为 log(K)，所以最坏时间代价为：K + (n-K) * log(K)；
>
> **结合概率**平均每个元素要比较的次数为：log(K)*K/n + 1*(n-K)/n，所以总时间复杂度是：K + (n-K) * [log(K)*K/n + 1*(n-K)/n]；

#### 下面对完全二叉树描述正确的是（）

> ```
> 叶子结点可在任一层出现
> 某些结点有有右子树则必有左子树
> 适用于顺序结构存储
> 不一定适合顺序结构存储
> ```

> 解析：BC
>
> 完全二叉树：叶节点只能出现在最下层和次下层，因为只能按顺序层次排序。

# C++

#### 对C++中重载（overload）和重写（override）描述正确的有（）

> ```
> A. 重载是指在同一个类或名字空间中存在多个函数，它们的函数名相同，而函数签名不同
> B. 重写是指在子类中实现一个虚函数，该虚函数与其父类中的一个虚函数拥有同样的函数签名
> C. 虚函数不可以重载
> D. 构造函数可以重载，析构函数可以重写
> ```

> 答案：ABD
>
> 解析：虚函数可以重载，并且 virtual 关键字可有可无（注：函数重载与有无virtual修饰无关）；

#### 以下哪些函数容易造成缓冲区溢出？

> ```
> strcpy
> strncat
> sprintf
> strcmp
> ```

> 答案：AC
>
> A. strcpy   没限制长度可能导致溢出（安全版本strncpy）
>
> B. strncat  限制了copy的长度就没问题，strcat可能导致溢出
>
> C. sprintf   和printf()一样，有格式化字符串攻击的可能
>
> D. strcmp  比较两个string长度，无危害

#### 以下关于C++语言中虚函数的描述正确的有（）

> ```
> 构造函数不可以是虚函数
> 析构函数不可以是纯虚函数
> 构造函数中不应该调用纯虚函数
> struct中不可以定义虚函数
> ```

> 解析：ABC
>
> B项存疑

# 概率

#### A和B两人在球场上进行踢点球比赛，两人交换着踢，先进球者获胜。A踢进的概率为0.6，B踢进的概率为0.5。假设A先踢，那么A最后获胜的概率最接近以下哪个选项？

> 答案：0.75
>
> 解析：
>
> A进球的次数肯定发生在第1，3，5，7...次，相应的概率为：
> 第一次进球：0.6
> 第三次进球：0.4*0.5*0.6
> 第五次进球：0.4*0.5*0.4*0.5*0.6
> 第n次进球：(0.4*0.5)^((n-1)/2)*0.6
>
> 概率的总和p=0.2^0*0.6+0.2^1*0.6+0.2^2*0.6+...+0.2^((n-1)/2)*0.6=0.6*(0.2^0+0.2^1+0.2^2+...+0.2^((n-1)/2))=0.6*（1-0.2^((n-1)/2))）/（1-0.2）=0.75-0.75*0.2^((n-1)/2))
>
> 当n趋紧于无穷大时，p=0.75，所以选择D

#### 在游戏Dota2中，有一位非常强大的英雄卡尔，他有三种属性：冰、火、雷。同时卡尔身上有三个无顺序的属性槽，他可以从三种属性中任意选择三个放入属性槽中，然后通过当前的属性组合召唤技能。每种不同的属性组合都可以为卡尔召唤出不同的技能，共有十种组合：

> 1、冰冰冰
> 2、冰冰火
> 3、冰冰雷
> 4、冰火火
> 5、冰火雷
> 6、冰雷雷
> 7、火火火
> 8、火火雷
> 9、火雷雷
> 10、雷雷雷
> 现在我们想继续加强卡尔，如果给卡尔四种属性：冰、火、雷、风，同时给卡尔四个无顺序的属性槽，从而让卡尔可以从四种属性中任意选择四个，则请问卡尔共可以召唤出多少种不同的技能？

> ```
> A.28
> B.35
> C.48
> D.64
> ```