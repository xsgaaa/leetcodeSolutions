### leetcode [301. 删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

```cpp
/*
	解法：深度优先搜索。
	以下思路摘自力扣评论区。https://leetcode-cn.com/problems/remove-invalid-parentheses/comments/。
过了一年，我也不知道这下面写的是啥了。。。看了好长时间，想起来了，解释一下，防止又忘记了。
###########
  ^     ^
  n     m
m 表示从 [0, m-1] 这一段都是正常的括号，正常，是指左括号数量比右括号多。 n 表示上一次操作，在这个位置删除了一个右括号。

remove 逻辑，先看一下平凡的思路：
从第 0 个位置开始向右扫描，一旦发现右括号多出来了，就必须要删除一个 [0, 当前位置] 的范围的右括号。删除掉后，[0, 当前位置] 就是一个符合条件的括号匹配，继续向右扫描，如果又遇到右括号多出来，再次从 [0, 当前位置] 删除一个右括号，这样直到所有不符合条件的右括号被删除。
把第 1 步得到的字符串，反转，按照同样的思路，把多出来的“右括号”（算法一样，只是以前的左括号要当成右括号来处理）删除。
经过以上 2 步的处理，最终处理的字符串就是符合要求的。
待会你会发现，如果按照上面的步骤操作，会产生重复的结果，这里有一些去重的 trick 逻辑，具体看下面的代码和示例分析。
// 0 1 2 3 4 5 6 7 8 9
// ( ( ) ( ) ) ) ) ( )
//             ^ 在这里发现右括号多了一个，可以删除 s[2], s[4], s[5], s[6] 中的任意一个
//               但是 s[4], s[5], s[6] 删除后，得出来的子串都是一样的，这里还需要去重
// 删除 s[2] 后，此时 m = 6, n = 2，这条分支记为 B1
// 0 1 2 3 4 5 6 7 8
// ( ( ( ) ) ) ) ( )
//     ^n      ^m
// 删除 s[4] 后, 此时 m = 6, n = 4，这条分支记为 B2
// 0 1 2 3 4 5 6 7 8
// ( ( ) ( ) ) ) ( )
//         ^n  ^m
// 接下来分析分支B2,(分支B1你可以类似分析)，删除 s[4] 后，产生的新串会丢给新的 remove 函数，继续从位置 m = 6 处扫描，但是没有必要从头开始
// 从位置 m = 6 这里继续扫描即可，发现 s[6] 又不符合条件，于是你又得在 s[0..m] 之间找到一个右括号删除。
//
// 0 1 2 3 4 5 6 7 8
// ( ( ) ( ) ) ) ( )
//         ^n  ^m
//
// 如果你不记录 n 的值，再次进入递归的时候，你又得从位置 0 开始重新找右括号，这时候你可能会删除 s[2]，
// 这就有问题了，s[2] 删除后变成下面这样。如果你分析了一下 B1 分支，你就会发现产生了一个重复串，和下面一模一样。
// 0 1 2 3 4 5 6 7 8
// ( ( ( ) ) ) ( )
//         ^n  ^m
// 所以 B2 分支，是不能从位置 0 开始寻找右括号删除，而应该从 n 这个位置开始寻找右括号去删除。删除之后变成下面这样
// 0 1 2 3 4 5 6 7 8
// ( ( ) ( ) ) ( )
//         ^n  ^m

*/
```

```cpp
vector<string> removeInvalidParentheses(string s) {
        vector<string> res;
        remove(s,0,0,{'(',')'},res);
        return res;
    }
private:
    void remove(string s,int l,int r,vector<char> p,vector<string> & res)
    {
        int cnt=0;
        for(int i=r;i<s.size();i++)
        {//统计从右边界开始的p[0]的数量
            if(s[i]==p[0]) cnt++;
            else if(s[i]==p[1])cnt--;	//用p[1]的数量抵消p[0]的数量
            if(cnt>=0) continue;		//p[0]的数量大于等于0.
            for(int j=l;j<=i;j++)		//当cnt的数量小于0时，表示不满足要求
            {
                //从左边界开始查找s[j]=p[1]，并进行删除
                //s[j]!=s[j-1]是为了剪枝，防止有重复的字符串
                if(s[j]==p[1] && (j==l || s[j]!=s[j-1]))	
                    remove(s.substr(0,j)+s.substr(j+1),j,i,p,res);
            }
            return;	//到达这一步，表示cnt<0
        }
        //到达张一步，表示cnt>=0.可能有一种字符的数量多了。
        //如果p[0]='('，表示左括号多了
        //如果p[1]=')',表示左右括号的数量相同了。因为上面应该把多余的左括号给删除了。
        string rev(s.rbegin(),s.rend());
        if(p[0]=='(')
            remove(rev,0,0,{')','('},res);
        else//递归终止条件，再经过正序的去除')'，逆序的去除'('之后，最后两者的数量一定相同。
            //经过翻转之后的顺序和原串相同，保存结果。
            res.push_back(rev);
    }
```

