# 牛客企业题库

## 1.进制转换

```
写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）
```

```cpp
#include<bits/stdc++.h>
using namespace std;
int  main()
{
    int num;
    while(cin>>hex>>num)//直接将十六进制数以十进制的方式读入
        cout<<num<<endl;
    return 0;
}
```

## 2.毕业旅行问题

```cpp
小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。
```

```cpp
//旅行商问题，用状态压缩dp做
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    int graph[n][n];
    memset(graph,0,sizeof graph);
    int e;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            cin>>e;
            graph[i][j]=e;
        }
    }
    int all=1<<n;
    int  dp[n][all];
    memset(dp,0x3f,sizeof dp);
    dp[0][1]=0;  //初始化经过0号结点的成本为0
    for(int j=1;j<all;j++)
    {//先遍历所有状态
        for(int i=0;i<n;i++)	//再遍历所有结点
        {//状态中不包含i，则直接跳过
            if(((j>>i)&1)==0)    continue;
            if(dp[i][j]!=0x3f3f3f3f)
            {
                for(int k=1;k<n;k++)
                {
                    if(k!=i && ((j>>k)&1)==0)
                        dp[k][j|(1<<k)]=min(dp[k][j|(1<<k)],dp[i][j]+graph[i][k]);
                    
                }
            }
        }
    }
    int ans=INT_MAX;
    for(int i=1;i<n;i++)
    {
        //cout<<dp[i][all-1]<<" ";
        ans=min(ans,dp[i][all-1]+graph[i][0]);
    }
    //cout<<endl;
    cout<<ans<<endl;
    return 0;
}
```

## 3.星际穿越

```
航天飞行器是一项复杂而又精密的仪器，飞行器的损耗主要集中在发射和降落的过程，科学家根据实验数据估计，如果在发射过程中，产生了 x 程度的损耗，那么在降落的过程中就会产生 x2 程度的损耗，如果飞船的总损耗超过了它的耐久度，飞行器就会爆炸坠毁。问一艘耐久度为 h 的飞行器，假设在飞行过程中不产生损耗，那么为了保证其可以安全的到达目的地，只考虑整数解，至多发射过程中可以承受多少程度的损耗？

每个输入包含一个测试用例。每个测试用例包含一行一个整数 h （1 <= h <= 10^18）。
```

```cpp
//x*(x+1)<h,要计算处x，不能用二分，二分的话如果mid很大的话，计算的结果会超过long long类型。
//先将h开方，然后递减计算即可
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main()
{
    ll h;
    cin>>h;
    ll k=sqrt(h);
    ll i=k;
    for(;i+i*i>h;i--)
    {
    }
    cout<<i<<endl;
    return 0;
}
```

# Bilibili 2020后端笔试题2

## 1.编辑距离

> 给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。
>
> 你总共三种操作方法：
>
> - 插入一个字符
> - 删除一个字符
> - 替换一个字符

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string str1,str2;
    while(cin>>str1>>str2)
    {
        int m=str1.size(),n=str2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,INT_MAX/2));
        
        for(int i=0;i<=m;i++)    dp[i][0]=i;//初始化值要注意
        for(int i=0;i<=n;i++)    dp[0][i]=i;
        
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                 if(str1[i-1]==str2[j-1])
                 {
                     dp[i][j]=dp[i-1][j-1];
                 }
                else
                {
                    int tmp=min(dp[i-1][j],dp[i][j-1]);
                    dp[i][j]=min(dp[i-1][j-1],tmp)+1;
                }
            }
        }
        cout<<dp[m][n]<<endl;
    }
    return 0;
}
```

## 2.给定一个正整数N，试求有多少组连续正整数满足所有数字之和为N? (1 <= N <= 10 ^ 9)

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    while(cin>>n)
    {
        if(n==0)
        {
            cout<<1<<endl;
            continue;
        }
        int N=sqrt(2*n);
        int cnt=0;
        for(int i=1;i<=N;i++)
        {
            int tmp=n-(i-1)*i/2.0;
            if(tmp%i==0)
                cnt++;
        }
        cout<<cnt<<endl;
    }
    return 0;
}
```

## 3.从标准输入读取字符串，按照指定的两层分隔符切分成多对key-value，依次输出到标准输出中。

注意：仅输出key和value都为非空串的pair。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<string,string> PII;
int main()
{
    string str;
    while(getline(cin,str))
    {
        if(str.size()<=3)
        {
            cout<<0<<endl;
            continue;
        }
        string c1,c2;
        int p1=str.find(' ',0);
        c1=str.substr(0,p1);            //分割键值对
        int p2=str.find(' ',p1+1);
        c2=str.substr(p1+1,p2-p1-1);    //分割k和v
        
        vector<string> key_val;
        int st=p2+1;
        while(st<str.size())
        {
            int pos=str.find(c1,st);
            if(string::npos==pos)
            {
                key_val.push_back(str.substr(st,str.size()-st));
                st=str.size(); 
            }
            else{
                key_val.push_back(str.substr(st,pos-st));
                st=pos+c1.size();
            }
        }
        vector<PII> ans;
        for(auto &s:key_val)
        {
            int pos=s.find(c2,0);
            if(pos==string::npos)    continue;
            ans.push_back({s.substr(0,pos),s.substr(c2.size()+pos)});
        }
        cout<<ans.size()<<endl;
        for(auto &p:ans)
            cout<<p.first<<" "<<p.second<<endl;
    }
    return 0;
}
```

# Bilibili 2020后端笔试题1

### 英文句子单词翻转

```cpp
原地翻转句子中单词的顺序，但单词内字符的顺序不变。要求：空间复杂度O(1)，时间复杂度O(n)。
```

```cpp
#include<bits/stdc++.h>
using namespace std;

void reverseStr(string &s,int l,int r)
{
    while(l<r)
    {
        swap(s[l],s[r]);
        l++,r--;
    }
}

int main()
{
    string s;
    while(getline(cin,s))
    {
        int l=0,r=s.size()-1;
        reverseStr(s,0,r);
        int i=0,j=0;
        while(j<=s.size())
        {
            if(j<s.size() && s[j]!=' ')
                j++;   
             else if(j==s.size() || s[j]==' ')
             {
                 reverseStr(s,i,j-1);
                 i=j+1;
                 j++;
             } 
        }
        cout<<s<<endl;
    }
    return 0;
}
```

## 数组排成最小的数

> 输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的一个。

```cpp
#include<bits/stdc++.h>
using namespace std;

bool cmp(string &s1,string &s2)
{
    return (s1+s2)<(s2+s1);//关键就这一句
}

int main()
{
    string s;
    while(getline(cin,s))
    {
        vector<string> v;
        int st=0;
        while(st<s.size())
        {
            int pos=s.find(',',st);
            if(pos==string::npos)
            {
                v.push_back(s.substr(st,s.size()-st));
                break;
            }
            else
            {
                v.push_back(s.substr(st,pos-st));
                st=pos+1;
            }
        }
        sort(v.begin(),v.end(),cmp);
        string ans;
        for(auto &str:v)
            ans+=str;
        cout<<ans<<endl;   
    }
    return 0;
}
```

## 0/1 背包问题

> 有为N件物品，它们的重量w分别是w1,w2,...,wn，它们的价值v分别是v1,v2,...,vn，每件物品数量有且仅有一个，现在给你个承重为M的背包，求背包里装入的物品具有的价值最大总和？

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int N,M;
    while(cin>>N>>M)
    {
        vector<int> v(N);
        vector<int> w(N);
        int num;
        for(int i=0;i<N;i++)
        {
            cin>>num;
            w[i]=num;
        }
        for(int i=0;i<N;i++)
        {
            cin>>num;
            v[i]=num;
        }
        int dp[N+1][M+1];
        memset(dp,0,sizeof dp);
        for(int i=1;i<=N;i++)
        {
             for(int j=w[i-1];j<=M;j++)
             {
                 dp[i][j]=dp[i-1][j];
                 dp[i][j]=max(dp[i][j],dp[i-1][j-w[i-1]]+v[i-1]);
             }
        }
        cout<<dp[N][M]<<endl;
    }
    return 0;
}
```

# 搜狗2020后端 （第一场）

### 服务器数据分发

```cpp
【题干描述】：
我们共有n台服务器，每台服务器可以和若干个子服务器传输数据，n台服务器组成一个树状结构。
现在要将一份数据从root节点开始分发给所有服务器。
一次数据传输需要一个小时时间，
一个节点可以同时对k个儿子节点进行并行传输，
不同节点可以并行分发。
问，全部分发完成，最短需要多少小时？

【示例】：
当共有5台服务器，其树状结构为
       0
     /     \
   1      2
  /   \
 3    4
假设每一台服务器同时可以对1个儿子节点（k=1）并行传输，最优的数据传输过程示例如下：
    第一个小时，0 -> 1；
    第二个小时，1->3 & 0->2；
    第三个小时，1 -> 4;
所以当k=1时，全部分发完成最短需要3个小时。
假设每一台服务器同时可以对2个儿子节点（k=2）并行传输，最优的数据传输过程示例如下：
    第一个小时，0 -> 1 & 0 -> 2;
    第二个小时，1 -> 3 & 1 -> 4;
所以当k=2时，全部分发完成最短需要2个小时。
```

```cpp
//树形DP
#include<bits/stdc++.h>
using namespace std;

int dfs(unordered_map<int,vector<int>> &g,int root,int &k)
{
    // 如果当前节点没有孩子，即使叶子节点，那么它就不需要分发，直接返回0
    if(!g.count(root))    return 0;
    //用于存储每个孩子节点分发完的时间
    vector<int> tree;
    for(auto &son:g[root])
    {
        tree.push_back(dfs(g,son,k));
    }
    sort(tree.begin(),tree.end(),greater<int>());
    // 计算root节点的分发时间
    // root分发的时候，先发给，那些分发完所需时间最长的子节点
    int res=0;
    for(int i=0;i<tree.size();i++)
    {
        tree[i]+=floor(i*1.0/k)+1;
        res=max(res,tree[i]);
    }
    return res;
}

int main()
{
    int k,n;
    while(cin>>k>>n)
    {
        int root,cnt,son;
        unordered_map<int,vector<int>> g;
        for(int i=0;i<n;i++)
        {
            cin>>cnt>>root;
            for(int j=1;j<cnt;j++)
            {
                cin>>son;
                g[root].push_back(son);
            }
        }
        cout<<dfs(g,0,k)<<endl;
    }
    return 0;
}
```

### 核子聚变

```cpp
请设计一个程序，在规定步数内，成功的使得一个原子核队列完全湮灭。

7种原子核(用A-G表示)，排成一条直线队列，在初始状态下它们是稳定的。
如果我们发射一个额外的原子核插入到队列，如果插入的位置没有形成大于等于3个相同的原子核的序列，那么队列继续保持稳定。
如果该位置上相邻的三个或以上的原子核种类相同， 就会诱发聚变湮灭成能量散失；然后队列上剩下的左右两半会受外部压力重新拼接在一起，拼接点两侧如果类型相同，且拼接后形成三个或以上连续相同序列，则连锁反映继续聚变湮灭。
为了方便描述插入位置，假定队列长度为n，我们把对列最左端外侧位置编号为0，右端外侧位置编号为n，共有n+1个位置。
例如：
AAABC，如果把一个A插入到位置4（或位置5）的时候，队列会变成AAABAC，继续稳定存在。
AABBCCA，如果把一个C插入到位置4（或位置5,6）的时候，会形成3个C，之后3个C会湮灭，队列变成AABBA，重新恢复稳定。
BAABBCCBACCB，一个C色球插入到位置5（或位置6,7）的时候，会触发连锁反应消去的过程如下（"+"表示拼接点）：
  BAABB+C+CCBACCCB => BAABB+BACCCB => BAA+ACCCB => B+CCCB => BCCCB (稳定)
  注意最后剩下3个连续的C，是因为最后一步拼接时，拼接点左右类型并不相同，不会触发连锁反应。

每在队列中新插入一个原子核，记为一步；每一步可插入任意类型的原子核。

本题给出1）初始的队列，2）要求在几步之内达成完全湮灭。
要求选手给出一个消去过程，将所有的原子核都聚变湮灭。该过程必须在给定的步数上限之内完成才算正确。
请选手注意，本题并不要求最优解，只需要给出一个不超过步数上限的解即可。
```

# 搜狗2020后端 （第二场）

## 2.密码生成

```cpp
小汪作为一个有数学天分的程序猿，设计了一套密码生成器来搞定自己的密码问题。
密码生成器由N个槽位组成，槽位的下标为0~N-1，每个槽位存储一个数。起初每个槽位都是0。
密码生成器会进行M轮计算，每轮计算，小汪会输入两个数L,R(L<=R),密码生成器会将这两个数作为下标，将两个下标之间（包含）的所有槽位赋值为i（i为当前的轮次，i∈[1,M]）。
M轮计算完成后，密码生成器会根据槽位的最终值生成一条密码，密码的生成规则为：
（0*a[0] + 1*a[1] + 2*a[2] + ... + (N-1)*a[N-1]) mod 100000009
其中a[i]表示第i个槽位的最终值。
请帮助小汪把他的密码生成器实现为代码。
```

```

```

## 3. IP过滤器

```cpp
在搜索引擎后端服务中，需要对恶意的抓取进行限制，其中的一个环节即对访问IP进行限制。请设计一个IP过滤器，实现对访问的IP限制的功能。对IP的限制数据有三种格式：
1.全IP：如222.205.58.16
2.前面带 *：如 *.58.16
3.后面带 *：如 222.205.58.*
带 * 的表示匹配到任意的IP段均可，且 * 可以代表多个ip段，且 * 只能出现在开头或者结尾。
现给出若干条需要过滤的规则，以及若干输入的IP，你需要输出这若干条IP是否会被过滤
```

```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_map<char,int> mp={{'.',10},{'*',11}};
//分割线分割的就是模板
//---------------------
struct Node
{
    bool is_End;
    Node* son[12];
    Node()
    {
        is_End=false;
        for(int i=0;i<12;i++)
            son[i]=NULL;
    }
}*root;
void insert(Node *p,string & str)
{
    for(int i=0;i<str.size();i++)
    {
        int u=isdigit(str[i])?(str[i]-'0'):mp[str[i]];
        if(!p->son[u])    p->son[u]=new Node();
        p=p->son[u];
    }
    p->is_End=true;
}
bool search(Node *p,string &str)
{
    for(int i=0;i<str.size();i++)
    {
        int u=isdigit(str[i])?(str[i]-'0'):mp[str[i]];
        if(!p->son[u])   return false;
        p=p->son[u];
        if(p->son[11])    return true;
    }
    return p->is_End;
}
//-----------------------------
int main()
{
    int N,M;
    while(cin>>N>>M)
    {
        root=new Node();
        string str;
        for(int i=0;i<N;i++)
        {
            cin>>str;
            insert(root,str);
            reverse(str.begin(),str.end());
            insert(root,str);
        }
        int ans;
        for(int i=0;i<M;i++)
        {
            ans=0;
            cin>>str;
            ans= ans || search(root,str);
            reverse(str.begin(),str.end());
            ans= ans || search(root,str);
            cout<<ans<<" ";
        }
    }
    return 0;
}

```

# 小红书2020后端(第三场)

## 1.薯券使用问题

> 某小红薯在小红书的活动中抽奖中了一定价值的薯券，这些薯券可以用来购买一批商品，求有多少种购买组合。其中一件商品可以买多件。
>
> 输 入:薯券金额、商品分别价格
>
> 输出 :组合数

```cpp
//完全背包
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int sum;
    string s;
    while(cin>>sum>>s)
    {
        s.pop_back();
        int st=1;
        vector<int> v;
        while(st<s.size())
        {
            int pos=s.find(',',st);
            if(pos==string::npos)
            {
                v.push_back(stoi(s.substr(st)));
                break;
            }
            else{
                v.push_back(stoi(s.substr(st,pos-st)));
                st=pos+1;
            }
        }
        int dp[sum+1];
        memset(dp,0,sizeof dp);
        dp[0]=1;
        sort(v.begin(),v.end(),less<int>());
        for(int i=0;i<v.size();i++)
        {
            for(int j=v[i];j<=sum;j++)
            {
                dp[j]=dp[j]+dp[j-v[i]];
            }
        }
        cout<<dp[sum]<<endl;
    }
    return 0;
}
```

## 2.笔记草稿

> 薯队长写了一篇笔记草稿，请你帮忙输出最后内容。
>
>  1.输入字符包括，"("  ,  ")"  和  "<"和其他字符。 
>
> 2.其他字符表示笔记内容。
>
>  3.()之间表示注释内容，任何字符都无效。  括号保证成对出现。
>
>  4."<"表示退格,  删去前面一个笔记内容字符。括号不受"<"影响  。 

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    while(getline(cin,s))
    {
        stack<char> st;
        int i=0;
        while(i<s.size())
        {
            if(s[i]=='<')
            {
                if(!st.empty()) st.pop();
            }
            else if(s[i]==')')
            {
                while(!st.empty() && st.top()!='(')
                    st.pop();
                st.pop();
            }
            else
                st.push(s[i]);
            i++;
        }
        string ans;
        while(!st.empty())
        {
            ans.push_back(st.top());
            st.pop();
        }
        reverse(ans.begin(),ans.end());
        cout<<ans<<endl;
    }
}
```

##  3.笔记精选

> 薯队长写了n篇笔记，编号从1~n,每篇笔记都获得了不少点赞数。    
> 薯队长想从中选出一些笔记，作一个精选集合。挑选的时候有两个规则：
>  1.不能出现连续编号的笔记。 
> 2.总点赞总数最多 
> 如果满足1，2条件有多种方案，挑选笔记总数最少的那种

```cpp
//类似于打家劫舍，其中求方案的方式要学会。
//转移的时候跟着记录一下就行
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    while(cin>>n)
    {
        vector<int> v(n+1);
        int num=0;
        for(int i=1;i<=n;i++)
        {
            cin>>num;
            v[i]=num;
        }
        int dp[n+1];
        int dpNum[n+1];
        memset(dpNum,0,sizeof dpNum);
        memset(dp,0,sizeof dp);
        dp[1]=v[1];dpNum[1]=1;
        for(int i=2;i<=n;i++)
        {
            if(dp[i-2]+v[i]>dp[i-1])
            {
                dp[i]=dp[i-2]+v[i];
                dpNum[i]=dpNum[i-2]+1;
            }
            else{
                dp[i]=dp[i-1];
                dpNum[i]=dpNum[i-1];
            }
        }      
        cout<<dp[n]<<" "<<dpNum[n]<<endl;
    }
    return 0;
}
```

## 4.倒卖战利品

> 在游戏中，击败魔物后，薯队长获得了N件宝物，接下来得把这些宝物卖给宝物回收员来赚点小钱。这个回收员有个坏毛病，每次卖给他一件宝 物后，之后他就看不上比这件宝物差的宝物了。在这个世界中，衡量宝物的好坏有两个维度，稀有度X和实用度H，回收员在回收一个宝物A 后，下一个宝物的稀有度和实用度都不能低于宝物A。那么薯队长如何制定售卖顺序，才能卖给回收员宝物总个数最多。 

```cpp
//利用最长上升子序列(二分优化版)
//当有两个维度时，将第一维排序，将第二维看作是一维的最长上升子序列
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
bool cmp(PII &p1,PII &p2)
{
    if(p1.first==p2.first)    return p1.second<p2.second;
    return p1.first<p2.first;
}
int main()
{
    int n;
    while(cin>>n)
    {
        vector<PII> vec;
        int u,v;
        for(int i=1;i<=n;i++)
        {
            cin>>u>>v;
            vec.push_back({u,v});
        }
        sort(vec.begin(),vec.end(),cmp);
        vector<int> nv;
        for(auto &p:vec)    nv.push_back(p.second);
        
        int ans=0;
        int dp[n];
        memset(dp,0,sizeof dp);
        
        for(auto &num:nv)
        {
            int l=0,r=ans;
            while(l<r)
            {
                int m=(l+r)/2;
                if(num<=dp[m])    r=m;
                else l=m+1;
            }
            dp[l]=num;
            if(l==ans)    ans++;
        }
        cout<<ans<<endl;
        
    }
    return 0;
}
```

