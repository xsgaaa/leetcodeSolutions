# 牛客企业题库

## 2.毕业旅行问题

```cpp
小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。
```

```cpp
//旅行商问题，用状态压缩dp做
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    int graph[n][n];
    memset(graph,0,sizeof graph);
    int e;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            cin>>e;
            graph[i][j]=e;
        }
    }
    int all=1<<n;
    int  dp[n][all];
    memset(dp,0x3f,sizeof dp);
    dp[0][1]=0;  //初始化经过0号结点的成本为0
    for(int j=1;j<all;j++)
    {//先遍历所有状态
        for(int i=0;i<n;i++)	//再遍历所有结点
        {//状态中不包含i，则直接跳过
            if(((j>>i)&1)==0)    continue;
            if(dp[i][j]!=0x3f3f3f3f)
            {
                for(int k=1;k<n;k++)
                {
                    if(k!=i && ((j>>k)&1)==0)
                        dp[k][j|(1<<k)]=min(dp[k][j|(1<<k)],dp[i][j]+graph[i][k]);
                    
                }
            }
        }
    }
    int ans=INT_MAX;
    for(int i=1;i<n;i++)
    {
        //cout<<dp[i][all-1]<<" ";
        ans=min(ans,dp[i][all-1]+graph[i][0]);
    }
    //cout<<endl;
    cout<<ans<<endl;
    return 0;
}
```

## 3.星际穿越

```
航天飞行器是一项复杂而又精密的仪器，飞行器的损耗主要集中在发射和降落的过程，科学家根据实验数据估计，如果在发射过程中，产生了 x 程度的损耗，那么在降落的过程中就会产生 x2 程度的损耗，如果飞船的总损耗超过了它的耐久度，飞行器就会爆炸坠毁。问一艘耐久度为 h 的飞行器，假设在飞行过程中不产生损耗，那么为了保证其可以安全的到达目的地，只考虑整数解，至多发射过程中可以承受多少程度的损耗？

每个输入包含一个测试用例。每个测试用例包含一行一个整数 h （1 <= h <= 10^18）。
```

```cpp
//x*(x+1)<h,要计算处x，不能用二分，二分的话如果mid很大的话，计算的结果会超过long long类型。
//先将h开方，然后递减计算即可
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main()
{
    ll h;
    cin>>h;
    ll k=sqrt(h);
    ll i=k;
    for(;i+i*i>h;i--)
    {
    }
    cout<<i<<endl;
    return 0;
}
```

# Bilibili 2020后端笔试题2

## 1.编辑距离

> 给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数。
>
> 你总共三种操作方法：
>
> - 插入一个字符
> - 删除一个字符
> - 替换一个字符

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string str1,str2;
    while(cin>>str1>>str2)
    {
        int m=str1.size(),n=str2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,INT_MAX/2));
        
        for(int i=0;i<=m;i++)    dp[i][0]=i;//初始化值要注意
        for(int i=0;i<=n;i++)    dp[0][i]=i;
        
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                 if(str1[i-1]==str2[j-1])
                 {
                     dp[i][j]=dp[i-1][j-1];
                 }
                else
                {
                    int tmp=min(dp[i-1][j],dp[i][j-1]);
                    dp[i][j]=min(dp[i-1][j-1],tmp)+1;
                }
            }
        }
        cout<<dp[m][n]<<endl;
    }
    return 0;
}
```

## 2.给定一个正整数N，试求有多少组连续正整数满足所有数字之和为N? (1 <= N <= 10 ^ 9)

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    while(cin>>n)
    {
        if(n==0)
        {
            cout<<1<<endl;
            continue;
        }
        int N=sqrt(2*n);
        int cnt=0;
        for(int i=1;i<=N;i++)
        {
            int tmp=n-(i-1)*i/2.0;
            if(tmp%i==0)
                cnt++;
        }
        cout<<cnt<<endl;
    }
    return 0;
}
```

## 3.从标准输入读取字符串，按照指定的两层分隔符切分成多对key-value，依次输出到标准输出中。

注意：仅输出key和value都为非空串的pair。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<string,string> PII;
int main()
{
    string str;
    while(getline(cin,str))
    {
        if(str.size()<=3)
        {
            cout<<0<<endl;
            continue;
        }
        string c1,c2;
        int p1=str.find(' ',0);
        c1=str.substr(0,p1);            //分割键值对
        int p2=str.find(' ',p1+1);
        c2=str.substr(p1+1,p2-p1-1);    //分割k和v
        
        vector<string> key_val;
        int st=p2+1;
        while(st<str.size())
        {
            int pos=str.find(c1,st);
            if(string::npos==pos)
            {
                key_val.push_back(str.substr(st,str.size()-st));
                st=str.size(); 
            }
            else{
                key_val.push_back(str.substr(st,pos-st));
                st=pos+c1.size();
            }
        }
        vector<PII> ans;
        for(auto &s:key_val)
        {
            int pos=s.find(c2,0);
            if(pos==string::npos)    continue;
            ans.push_back({s.substr(0,pos),s.substr(c2.size()+pos)});
        }
        cout<<ans.size()<<endl;
        for(auto &p:ans)
            cout<<p.first<<" "<<p.second<<endl;
    }
    return 0;
}
```

# Bilibili 2020后端笔试题1

### 英文句子单词翻转

```cpp
原地翻转句子中单词的顺序，但单词内字符的顺序不变。要求：空间复杂度O(1)，时间复杂度O(n)。
```

```cpp
#include<bits/stdc++.h>
using namespace std;

void reverseStr(string &s,int l,int r)
{
    while(l<r)
    {
        swap(s[l],s[r]);
        l++,r--;
    }
}

int main()
{
    string s;
    while(getline(cin,s))
    {
        int l=0,r=s.size()-1;
        reverseStr(s,0,r);
        int i=0,j=0;
        while(j<=s.size())
        {
            if(j<s.size() && s[j]!=' ')
                j++;   
             else if(j==s.size() || s[j]==' ')
             {
                 reverseStr(s,i,j-1);
                 i=j+1;
                 j++;
             } 
        }
        cout<<s<<endl;
    }
    return 0;
}
```

## 数组排成最小的数

> 输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的一个。

```cpp
#include<bits/stdc++.h>
using namespace std;

bool cmp(string &s1,string &s2)
{
    return (s1+s2)<(s2+s1);//关键就这一句
}

int main()
{
    string s;
    while(getline(cin,s))
    {
        vector<string> v;
        int st=0;
        while(st<s.size())
        {
            int pos=s.find(',',st);
            if(pos==string::npos)
            {
                v.push_back(s.substr(st,s.size()-st));
                break;
            }
            else
            {
                v.push_back(s.substr(st,pos-st));
                st=pos+1;
            }
        }
        sort(v.begin(),v.end(),cmp);
        string ans;
        for(auto &str:v)
            ans+=str;
        cout<<ans<<endl;   
    }
    return 0;
}
```

## 0/1 背包问题

> 有为N件物品，它们的重量w分别是w1,w2,...,wn，它们的价值v分别是v1,v2,...,vn，每件物品数量有且仅有一个，现在给你个承重为M的背包，求背包里装入的物品具有的价值最大总和？

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int N,M;
    while(cin>>N>>M)
    {
        vector<int> v(N);
        vector<int> w(N);
        int num;
        for(int i=0;i<N;i++)
        {
            cin>>num;
            w[i]=num;
        }
        for(int i=0;i<N;i++)
        {
            cin>>num;
            v[i]=num;
        }
        int dp[N+1][M+1];
        memset(dp,0,sizeof dp);
        for(int i=1;i<=N;i++)
        {
             for(int j=w[i-1];j<=M;j++)
             {
                 dp[i][j]=dp[i-1][j];
                 dp[i][j]=max(dp[i][j],dp[i-1][j-w[i-1]]+v[i-1]);
             }
        }
        cout<<dp[N][M]<<endl;
    }
    return 0;
}
```

# 搜狗2020后端 （第一场）

### 服务器数据分发

```cpp
【题干描述】：
我们共有n台服务器，每台服务器可以和若干个子服务器传输数据，n台服务器组成一个树状结构。
现在要将一份数据从root节点开始分发给所有服务器。
一次数据传输需要一个小时时间，
一个节点可以同时对k个儿子节点进行并行传输，
不同节点可以并行分发。
问，全部分发完成，最短需要多少小时？

【示例】：
当共有5台服务器，其树状结构为
       0
     /     \
   1      2
  /   \
 3    4
假设每一台服务器同时可以对1个儿子节点（k=1）并行传输，最优的数据传输过程示例如下：
    第一个小时，0 -> 1；
    第二个小时，1->3 & 0->2；
    第三个小时，1 -> 4;
所以当k=1时，全部分发完成最短需要3个小时。
假设每一台服务器同时可以对2个儿子节点（k=2）并行传输，最优的数据传输过程示例如下：
    第一个小时，0 -> 1 & 0 -> 2;
    第二个小时，1 -> 3 & 1 -> 4;
所以当k=2时，全部分发完成最短需要2个小时。
```

```cpp
//树形DP
#include<bits/stdc++.h>
using namespace std;

int dfs(unordered_map<int,vector<int>> &g,int root,int &k)
{
    // 如果当前节点没有孩子，即使叶子节点，那么它就不需要分发，直接返回0
    if(!g.count(root))    return 0;
    //用于存储每个孩子节点分发完的时间
    vector<int> tree;
    for(auto &son:g[root])
    {
        tree.push_back(dfs(g,son,k));
    }
    sort(tree.begin(),tree.end(),greater<int>());
    // 计算root节点的分发时间
    // root分发的时候，先发给，那些分发完所需时间最长的子节点
    int res=0;
    for(int i=0;i<tree.size();i++)
    {
        tree[i]+=floor(i*1.0/k)+1;
        res=max(res,tree[i]);
    }
    return res;
}

int main()
{
    int k,n;
    while(cin>>k>>n)
    {
        int root,cnt,son;
        unordered_map<int,vector<int>> g;
        for(int i=0;i<n;i++)
        {
            cin>>cnt>>root;
            for(int j=1;j<cnt;j++)
            {
                cin>>son;
                g[root].push_back(son);
            }
        }
        cout<<dfs(g,0,k)<<endl;
    }
    return 0;
}
```

### 核子聚变

```cpp
请设计一个程序，在规定步数内，成功的使得一个原子核队列完全湮灭。

7种原子核(用A-G表示)，排成一条直线队列，在初始状态下它们是稳定的。
如果我们发射一个额外的原子核插入到队列，如果插入的位置没有形成大于等于3个相同的原子核的序列，那么队列继续保持稳定。
如果该位置上相邻的三个或以上的原子核种类相同， 就会诱发聚变湮灭成能量散失；然后队列上剩下的左右两半会受外部压力重新拼接在一起，拼接点两侧如果类型相同，且拼接后形成三个或以上连续相同序列，则连锁反映继续聚变湮灭。
为了方便描述插入位置，假定队列长度为n，我们把对列最左端外侧位置编号为0，右端外侧位置编号为n，共有n+1个位置。
例如：
AAABC，如果把一个A插入到位置4（或位置5）的时候，队列会变成AAABAC，继续稳定存在。
AABBCCA，如果把一个C插入到位置4（或位置5,6）的时候，会形成3个C，之后3个C会湮灭，队列变成AABBA，重新恢复稳定。
BAABBCCBACCB，一个C色球插入到位置5（或位置6,7）的时候，会触发连锁反应消去的过程如下（"+"表示拼接点）：
  BAABB+C+CCBACCCB => BAABB+BACCCB => BAA+ACCCB => B+CCCB => BCCCB (稳定)
  注意最后剩下3个连续的C，是因为最后一步拼接时，拼接点左右类型并不相同，不会触发连锁反应。

每在队列中新插入一个原子核，记为一步；每一步可插入任意类型的原子核。

本题给出1）初始的队列，2）要求在几步之内达成完全湮灭。
要求选手给出一个消去过程，将所有的原子核都聚变湮灭。该过程必须在给定的步数上限之内完成才算正确。
请选手注意，本题并不要求最优解，只需要给出一个不超过步数上限的解即可。
```

# 搜狗2020后端 （第二场）

## 2.密码生成

```cpp
小汪作为一个有数学天分的程序猿，设计了一套密码生成器来搞定自己的密码问题。
密码生成器由N个槽位组成，槽位的下标为0~N-1，每个槽位存储一个数。起初每个槽位都是0。
密码生成器会进行M轮计算，每轮计算，小汪会输入两个数L,R(L<=R),密码生成器会将这两个数作为下标，将两个下标之间（包含）的所有槽位赋值为i（i为当前的轮次，i∈[1,M]）。
M轮计算完成后，密码生成器会根据槽位的最终值生成一条密码，密码的生成规则为：
（0*a[0] + 1*a[1] + 2*a[2] + ... + (N-1)*a[N-1]) mod 100000009
其中a[i]表示第i个槽位的最终值。
请帮助小汪把他的密码生成器实现为代码。
```

```

```

## 3. IP过滤器

```cpp
在搜索引擎后端服务中，需要对恶意的抓取进行限制，其中的一个环节即对访问IP进行限制。请设计一个IP过滤器，实现对访问的IP限制的功能。对IP的限制数据有三种格式：
1.全IP：如222.205.58.16
2.前面带 *：如 *.58.16
3.后面带 *：如 222.205.58.*
带 * 的表示匹配到任意的IP段均可，且 * 可以代表多个ip段，且 * 只能出现在开头或者结尾。
现给出若干条需要过滤的规则，以及若干输入的IP，你需要输出这若干条IP是否会被过滤
```

```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_map<char,int> mp={{'.',10},{'*',11}};
//分割线分割的就是模板
//---------------------
struct Node
{
    bool is_End;
    Node* son[12];
    Node()
    {
        is_End=false;
        for(int i=0;i<12;i++)
            son[i]=NULL;
    }
}*root;
void insert(Node *p,string & str)
{
    for(int i=0;i<str.size();i++)
    {
        int u=isdigit(str[i])?(str[i]-'0'):mp[str[i]];
        if(!p->son[u])    p->son[u]=new Node();
        p=p->son[u];
    }
    p->is_End=true;
}
bool search(Node *p,string &str)
{
    for(int i=0;i<str.size();i++)
    {
        int u=isdigit(str[i])?(str[i]-'0'):mp[str[i]];
        if(!p->son[u])   return false;
        p=p->son[u];
        if(p->son[11])    return true;
    }
    return p->is_End;
}
//-----------------------------
int main()
{
    int N,M;
    while(cin>>N>>M)
    {
        root=new Node();
        string str;
        for(int i=0;i<N;i++)
        {
            cin>>str;
            insert(root,str);
            reverse(str.begin(),str.end());
            insert(root,str);
        }
        int ans;
        for(int i=0;i<M;i++)
        {
            ans=0;
            cin>>str;
            ans= ans || search(root,str);
            reverse(str.begin(),str.end());
            ans= ans || search(root,str);
            cout<<ans<<" ";
        }
    }
    return 0;
}

```

# 小红书2020后端(第三场)

## 1.薯券使用问题

> 某小红薯在小红书的活动中抽奖中了一定价值的薯券，这些薯券可以用来购买一批商品，求有多少种购买组合。其中一件商品可以买多件。
>
> 输 入:薯券金额、商品分别价格
>
> 输出 :组合数

```cpp
//完全背包
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int sum;
    string s;
    while(cin>>sum>>s)
    {
        s.pop_back();
        int st=1;
        vector<int> v;
        while(st<s.size())
        {
            int pos=s.find(',',st);
            if(pos==string::npos)
            {
                v.push_back(stoi(s.substr(st)));
                break;
            }
            else{
                v.push_back(stoi(s.substr(st,pos-st)));
                st=pos+1;
            }
        }
        int dp[sum+1];
        memset(dp,0,sizeof dp);
        dp[0]=1;
        sort(v.begin(),v.end(),less<int>());
        for(int i=0;i<v.size();i++)
        {
            for(int j=v[i];j<=sum;j++)
            {
                dp[j]=dp[j]+dp[j-v[i]];
            }
        }
        cout<<dp[sum]<<endl;
    }
    return 0;
}
```

## 2.笔记草稿

> 薯队长写了一篇笔记草稿，请你帮忙输出最后内容。
>
>  1.输入字符包括，"("  ,  ")"  和  "<"和其他字符。 
>
> 2.其他字符表示笔记内容。
>
>  3.()之间表示注释内容，任何字符都无效。  括号保证成对出现。
>
>  4."<"表示退格,  删去前面一个笔记内容字符。括号不受"<"影响  。 

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    while(getline(cin,s))
    {
        stack<char> st;
        int i=0;
        while(i<s.size())
        {
            if(s[i]=='<')
            {
                if(!st.empty()) st.pop();
            }
            else if(s[i]==')')
            {
                while(!st.empty() && st.top()!='(')
                    st.pop();
                st.pop();
            }
            else
                st.push(s[i]);
            i++;
        }
        string ans;
        while(!st.empty())
        {
            ans.push_back(st.top());
            st.pop();
        }
        reverse(ans.begin(),ans.end());
        cout<<ans<<endl;
    }
}
```

##  3.笔记精选

> 薯队长写了n篇笔记，编号从1~n,每篇笔记都获得了不少点赞数。    
> 薯队长想从中选出一些笔记，作一个精选集合。挑选的时候有两个规则：
>  1.不能出现连续编号的笔记。 
> 2.总点赞总数最多 
> 如果满足1，2条件有多种方案，挑选笔记总数最少的那种

```cpp
//类似于打家劫舍，其中求方案的方式要学会。
//转移的时候跟着记录一下就行
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    while(cin>>n)
    {
        vector<int> v(n+1);
        int num=0;
        for(int i=1;i<=n;i++)
        {
            cin>>num;
            v[i]=num;
        }
        int dp[n+1];
        int dpNum[n+1];
        memset(dpNum,0,sizeof dpNum);
        memset(dp,0,sizeof dp);
        dp[1]=v[1];dpNum[1]=1;
        for(int i=2;i<=n;i++)
        {
            if(dp[i-2]+v[i]>dp[i-1])
            {
                dp[i]=dp[i-2]+v[i];
                dpNum[i]=dpNum[i-2]+1;
            }
            else{
                dp[i]=dp[i-1];
                dpNum[i]=dpNum[i-1];
            }
        }      
        cout<<dp[n]<<" "<<dpNum[n]<<endl;
    }
    return 0;
}
```

## 4.倒卖战利品

> 在游戏中，击败魔物后，薯队长获得了N件宝物，接下来得把这些宝物卖给宝物回收员来赚点小钱。这个回收员有个坏毛病，每次卖给他一件宝 物后，之后他就看不上比这件宝物差的宝物了。在这个世界中，衡量宝物的好坏有两个维度，稀有度X和实用度H，回收员在回收一个宝物A 后，下一个宝物的稀有度和实用度都不能低于宝物A。那么薯队长如何制定售卖顺序，才能卖给回收员宝物总个数最多。 

```cpp
//利用最长上升子序列(二分优化版)
//当有两个维度时，将第一维排序，将第二维看作是一维的最长上升子序列
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
bool cmp(PII &p1,PII &p2)
{
    if(p1.first==p2.first)    return p1.second<p2.second;
    return p1.first<p2.first;
}
int main()
{
    int n;
    while(cin>>n)
    {
        vector<PII> vec;
        int u,v;
        for(int i=1;i<=n;i++)
        {
            cin>>u>>v;
            vec.push_back({u,v});
        }
        sort(vec.begin(),vec.end(),cmp);
        vector<int> nv;
        for(auto &p:vec)    nv.push_back(p.second);
        
        int ans=0;
        int dp[n];
        memset(dp,0,sizeof dp);
        
        for(auto &num:nv)
        {
            int l=0,r=ans;
            while(l<r)
            {
                int m=(l+r)/2;
                if(num<=dp[m])    r=m;
                else l=m+1;
            }
            dp[l]=num;
            if(l==ans)    ans++;
        }
        cout<<ans<<endl;
        
    }
    return 0;
}
```

# 小红书2020后端(第一场)

## 击败魔物

> 薯队长来到了迷宫的尽头，面前出现了N只魔物，Hi表示第i只魔物的血量，薯队长需要在T个回合内击败所有魔物才能获胜。每个回合薯队长可 以选择物理攻击一只魔物，对其造成1点伤害（物理攻击次数无上限）;    或者消耗1点法力释放必杀技对其造成固定X点伤害（薯队长开始拥有M 点法力）。问X至少多大，薯队长才有机会获胜；如果无论如何都无法在T回合内获胜，则输出-1 
>
> ##### **输入描述:**
>
> ```
> 第一行三个整数分别表示：N，T，M 第二行有N个整数：H1，H2，H3...HN 
> ```
>
> ##### **输出描述:**
>
> ```
> 输出一个整数，表示必杀技一次最少造成多少固定伤害
> ```

```cpp
//解法;贪心+二分

//先对打出最大伤害。
//然后如果魔力没用完：就用魔力先打那些剩余血量比较多的;
//魔力用完之后，只能平A，判断回合数是否大于等于剩余怪物的血量和。

#include<bits/stdc++.h>
using namespace std;
bool check(vector<int> &H,int x,int T,int M)
{
    vector<int> help(H.begin(),H.end());
    sort(help.begin(),help.end(),greater<int>());
    for(auto &num:help)
    {
        int a=min(num/x,M);
        T-=a;
        M-=a;
        num-=a*x;
        if(M==0)    break;
    }
    int sum=accumulate(help.begin(),help.end(),0);
    if(M==0 && T>=sum)    return true;
    if(M==0 && T<sum)    return false;
    sort(help.begin(),help.end(),greater<int>());
    for(auto &num:help)
    {
        M--;
        T--;
        num=0;
        if(M==0) break;
    }
    sum=accumulate(help.begin(),help.end(),0);
    if(T>=sum)    return true;
    else return false;
}

int main()
{
    int N,T,M;
    while(cin>>N>>T>>M)
    {
        vector<int> H(N);
        int num;
        int maxv=INT_MIN,minv=INT_MAX;
        for(int i=0;i<N;i++)
        {
            cin>>num;
            maxv=max(maxv,num);
            minv=min(minv,num);
            H[i]=num;
        }
        int sum=accumulate(H.begin(),H.end(),0);
        if((minv>=1 && N>T) ||(sum>T && M==0))
        {//回合数不足 或者 没有法力值 必然失败
            cout<<-1<<endl;
            continue;
        }
        if(maxv==1 && N<=T)
        {//平A获胜
            cout<<0<<endl;
            continue;
        }
        
        //M=min(M,T);
        
        int l=0,r=maxv;
        while(l<r)
        {//二分搜索答案
            int x=(r+l)/2;
            if(check(H,x,T,M))
                r=x;
            else
                l=x+1;
        }
        if(l==maxv)
            cout<<-1<<endl;
        else
           cout<<l<<endl; 
    }
    return 0;
}
```

## 迷宫游戏

> 薯队长最近在玩一个迷宫探索类游戏，迷宫是一个N*N的矩阵形状，其中会有一些障碍物禁止通过。这个迷宫还有一个特殊的设计，它的左右 边界以及上下边界是连通的，比如在(2,n)的位置继续往右走一格可以到(2,1)，  在(1,2)的位置继续往上走一格可以到(n,2)。请问薯队长从起点位置S，最少走多少格才能到达迷宫的出口位置E。 

```cpp
//广度优先遍历-层次遍历即可
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
#define x first
#define y second
int main()
{
    int N;
    while(cin>>N)
    {
        vector<string> g(N);
        string line;
        PII st,end;
        for(int i=0;i<N;i++)
        {
            cin>>line;
            for(int j=0;j<N;j++)
            {
                if(line[j]=='S')   st={i,j};
                if(line[j]=='E')    end={i,j};
            }
            g[i]=line;
        }
        //cout<<st.x<<" "<<st.y<<endl;
        queue<PII> q;
        q.push(st);
        int cnt=0;
        bool vis[N][N];
        memset(vis,0,sizeof vis);
        int dirs[5]={1,0,-1,0,1};
        vis[st.x][st.y]=true;
        bool flag=false;
        while(!q.empty())
        {
            int size=q.size();
            for(int i=0;i<size;i++)
            {
                auto cur=q.front(); q.pop();
                if(cur.x==end.x && cur.y==end.y)
                {
                    cout<<cnt<<endl;
                    flag=true;
                    break;
                }
                for(int k=0;k<4;k++)
                {
                    int ni=cur.x+dirs[k],nj=cur.y+dirs[k+1];
                    if(ni==-1) ni=N-1;
                    else if(ni==N) ni=0;
                    if(nj==-1) nj=N-1;
                    else if(nj==N) nj=0;
                    if(vis[ni][nj] || g[ni][nj]=='#') continue;
                    q.push({ni,nj});
                    vis[ni][nj]=true;
                }
            }
            cnt++;
        }
        if(!flag)
            cout<<-1<<endl;
    }
    return 0;
}
```

# 华为研发工程师编程题

## 汽水瓶

> 简单题。略。

## 明明的随机数

> 简单题。略。

## 进制转换

> 写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int num;
    while(cin>>hex>>num)//可以利用cin>>hex直接读取十六进制的数，然后保存
        cout<<num<<endl;
    return 0;
}
```

# 华为2016研发工程师编程题

## 删数

> 有一个数组a[N]顺序存放0~N-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。以8个数(N=7)为例:｛0，1，2，3，4，5，6，7｝，0->1->2(删除)->3->4->5(删除)->6->7->0(删除),如此循环直到最后一个数被删除。

```cpp
//约瑟夫环问题
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    while(cin>>n)
    {
        n=min(n,1000);
        int last=0;
        for(int i=2;i<=n;i++)
        {
            last=(last+3)%i;
        }
        cout<<last<<endl;
    }
    return 0;
}
```

##  字符集合

> 过于简单。略。

## 数独

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;

bool flag;
void dfs(int cur,int n,vector<PII> &v,bitset<9> rows[],
        bitset<9> cols[], bitset<9> mat[],vector<vector<int>> &g)
{
    if(cur==n)
    {
        flag=true;
        return;
    }
    int x=v[cur].first,y=v[cur].second;
    for(int i=1;i<=9;i++)
    {
        if(rows[x][i]==1 || cols[y][i]==1 || mat[x/3*3+y/3][i]==1)
            continue;
        rows[x][i]=1;
        cols[y][i]=1;
        mat[x/3*3+y/3][i]=1;
        g[x][y]=i;
        
        dfs(cur+1,n,v,rows,cols,mat,g);
        if(flag)    return;
        
        rows[x][i]=0;
        cols[y][i]=0;
        mat[x/3*3+y/3][i]=0;
    }
}

int main()
{ 
    vector<vector<int>> g(9,vector<int>(9));
    vector<PII> v;
    int num;
    bitset<9> rows[9],cols[9],mat[9];
    for(int i=0;i<9;i++)
    {
        for(int j=0;j<9;j++)
        {
            cin>>num;
            g[i][j]=num;
            if(num==0)    
            {
                v.push_back({i,j});
            }
            else
            {
                rows[i][num]=1;
                cols[j][num]=1;
                mat[i/3*3+j/3]=1;
            }
        }
    }
    flag=false;
    dfs(0,v.size(),v,rows,cols,mat,g);
    for(int i=0;i<9;i++)
    {
        for(int j=0;j<9;j++)
            cout<<g[i][j]<<" ";
        cout<<endl;
    }
    
    return 0;
}
```

# 华为2016校园招聘上机笔试题

## 最高分是多少

```cpp
//直接暴力循环，居然过了
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int N,M;
    while(cin>>N>>M)
    {
        int stu[N+1];
        stu[0]=0;
        for(int i=1;i<=N;i++)    cin>>stu[i];
        char c;
        int A,B;
        while(M--)
        {
            cin>>c>>A>>B;
            if(c=='Q')
            {
                int maxv=0;
                int l=min(A,B),r=max(A,B);
                for(int i=l;i<=r;i++)
                    maxv=max(maxv,stu[i]);
                cout<<maxv<<endl;
            }
            else
            {
                stu[A]=B;
            }
        }
    }
    return 0;
}
```

## 简单错误记录

> 开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。
> 处理:
> 1.记录最多8条错误记录，对相同的错误记录(即文件名称和行号完全匹配)只记录一条，错误计数增加；(文件所在的目录不同，文件名和行号相同也要合并)
> 2.超过16个字符的文件名称，只记录文件的最后有效16个字符；(如果文件名不同，而只是文件名的后16个字符和行号相同，也不要合并)
> 3.输入的文件可能带路径，记录文件名称不能带路径

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef pair<int,int> PII;
#define x first
#define y second

struct cmp
{//仿函数
    bool operator()(const PII &p1,const PII &p2)
    {
        if(p1.x==p2.x)    return p1.y<p2.y;
        return p1.x>p2.x;
    }
};


int main()
{
    unordered_map<string,unordered_map<int,PII>> mp;
    string s;
    int line,cnt=0;
    
    while(cin>>s>>line)
    {
        int pos=s.rfind("\\",s.size()-1);//逆序查找'\’出现的位置，注意是从最后一个索引开始
        if(pos!=string::npos)
        {
            s=s.substr(pos+1);		//截取'\'右端的字符串
        }
        //先把所有的字符串都放进去，因为这样才知道哪些字符串数量最大
        if(!mp.count(s))
        {
            mp[s][line].x++;
            mp[s][line].y=cnt++;
        }
        else if(mp.count(s) && !mp[s].count(line))
        {
            mp[s][line].x++;
            mp[s][line].y=cnt++;
        }
        else if(mp.count(s) && mp[s].count(line))
        {
            mp[s][line].x++;
        }       
    }
    
    map<PII,pair<string,int>,cmp> _map;	//再创建一个map来存储结果，重写了map对key的比较规则
    for(auto &p:mp)
    {
        for(auto &pson:p.y)
        {
            _map.insert({pson.y,{p.x,pson.x}});
        }
    }
    int num=0;//用于控制前8个数量
    for(auto &p:_map)
    {
        if(num>=8) break;
        string &str=p.y.x;
        if(str.size()>16)    cout<<str.substr(str.size()-16);
        else cout<<str;
        cout<<" "<<p.y.y<<" "<<p.x.x<<endl;
        num++;
    }
    return 0;
}
```

## 扑克牌大小

> 扑克牌游戏大家应该都比较熟悉了，一副牌由54张组成，含3~A，2各4张，小王1张，大王1张。牌面从小到大用如下字符和字符串表示（其中，小写joker表示小王，大写JOKER表示大王）:)
> 3 4 5 6 7 8 9 10 J Q K A 2 joker JOKER
> 输入两手牌，两手牌之间用“-”连接，每手牌的每张牌以空格分隔，“-”两边没有空格，如：4 4 4 4-joker JOKER
> 请比较两手牌大小，输出较大的牌，如果不存在比较关系则输出ERROR
>
> 基本规则：
> （1）输入每手牌可能是个子，对子，顺子（连续5张），三个，炸弹（四个）和对王中的一种，不存在其他情况，由输入保证两手牌都是合法的，顺子已经从小到大排列；
> （2）除了炸弹和对王可以和所有牌比较之外，其他类型的牌只能跟相同类型的存在比较关系（如，对子跟对子比较，三个跟三个比较），不考虑拆牌情况（如：将对子拆分成个子）
> （3）大小规则跟大家平时了解的常见规则相同，个子，对子，三个比较牌面大小；顺子比较最小牌大小；炸弹大于前面所有的牌，炸弹之间比较牌面大小；对王是最大的牌；
> （4）输入的两手牌不会出现相等的情况。
> 答案提示：
> （1）除了炸弹和对王之外，其他必须同类型比较。
> （2）输入已经保证合法性，不用检查输入是否是合法的牌。
> （3）输入的顺子已经经过从小到大排序，因此不用再排序了

```cpp
#include<bits/stdc++.h>
using namespace std;

void parseStr(string &str,vector<int> &v)
{
    int i=0;
    while(i<str.size())
    {
        int pos=str.find(' ',i);
        if(pos==string::npos)
        {
            string tmp=str.substr(i);
            if(tmp=="A") v.push_back(1);
            else if(tmp=="J") v.push_back(11);
            else if(tmp=="Q") v.push_back(12);
            else if(tmp=="K") v.push_back(13);
            else v.push_back(stoi(tmp));
            break;
        }
        else{
            string tmp=str.substr(i,pos-i);
            if(tmp=="A") v.push_back(1);
            else if(tmp=="J") v.push_back(11);
            else if(tmp=="Q") v.push_back(12);
            else if(tmp=="K") v.push_back(13);
            else v.push_back(stoi(tmp));
            i=pos+1;
        }
    }
}

int main()
{
    string s;
    while(getline(cin,s))
    {
        int pos=s.find("-",0);
        string one=s.substr(0,pos);
        string two=s.substr(pos+1);
        //存在大小王,先排除
        if(one=="joker JOKER" || one=="JOKER joker")
        {
            cout<<one<<endl;
            continue;
        }
        if(two=="joker JOKER" || two=="JOKER joker")
        {
            cout<<two<<endl;
            continue;
        }
        
        vector<int> a;
        vector<int> b;
        parseStr(one, a);	//解析字符串中牌
        parseStr(two, b);
        //排除有炸弹的可能
        if(a.size()==4 || b.size()==4)
        {
            if(b.size()==4 && a[0]<b[0]) cout<<two<<endl;
            else cout<<one<<endl; 
            continue;
        }
        //剩下的应该是两者相同，如果牌数不同
        if(a.size()!=b.size())
        {
            cout<<"ERROR"<<endl;
            continue;
        }
        //牌数相同。 注意： A 2 比后面的数大
        if(a[0]<b[0] && a[0]>=2) cout<<two<<endl;
        else cout<<one<<endl;
    }
    return 0;
}
```

# 猿辅导2020校招笔试(三)

## 发水果(其实就是逆序打印二维数组)

```
答案略。注意下标不要写错。
```

## 小猿的冠军班级

```
有空再写，稍微复杂。
```

###  课程质量建设

```cpp
//利用滑动窗口。
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int N,S;
    while(cin>>N>>S)
    {
        int cla[N];
        for(int i=0;i<N;i++)
        {
            cin>>cla[i];
        }
        int l=0,r=0,sum=0;
        int ans=0;
        while(r<N)
        {
            sum+=cla[r];
            while(sum>S)
            {
                ans=max(ans,r-l);
                sum-=cla[l];
                l++;
            }
            r++;
        }
        if(sum<=S)    ans=max(ans,N-l);
        cout<<ans<<endl;
    }
    return 0;
}
```

# 猿辅导2020校招笔试(二)

### 去除捣乱的报数

```cpp
猿辅导老师在直播课上和同学们做游戏，让同学们在聊天区报自己的学号，每报一次可以获得一个礼物。但是老师不给报数次数超过了一定的次数的同学发礼物。
现在请你来帮助老师把聊天区的报数数列处理一下。
规定，当发现某个数大于 m 次时，则认定为报数过多，我们需要得到去除这些学生的报数后的报数数列。
```

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int N,M;
    while(cin>>N>>M)
    {
        int num[N];
        for(int i=0;i<N;i++)
        {
            cin>>num[i];
        }
        int i=0,j=0;
        vector<int> ans;
        while(j<N)
        {
            if(num[i]==num[j])
            {
                j++;
                continue;
            }
            if(j-i<=M)
            {
                for(int k=0;k<j-i;k++)    
                    ans.push_back(num[i]);
            }
            i=j;
            j++;
        }
        if(j-i<=M)
        {
            for(int k=0;k<j-i;k++)    
               ans.push_back(num[i]); 
        }
        for(auto &i:ans)    cout<<i<<" ";
        cout<<endl;
    }
    return 0;
}
```



## 分组对话

```cpp
猿辅导课堂上老师提供了一些角色，学生可以从中选择一个自己喜欢的角色扮演，每3个不同的角色就可以组成一个小组，进行分组对话。
当老师点击开始分组对话按钮的时候，服务器会为已经选择自己角色的同学分配对话小组，请问最多能组成多少个对话小组？
输入描述:
第一行为测试用例数量C(C<=100)，接下来的C行每行为一个测试用例
每个用例的第一个数字表示可供选择的角色数量T(T<=1000)，接下来的T个数字表示每个角色的选择人数Pi(Pi<=500)
```

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int C;
    cin>>C;
    while(C--)
    {
        int T;
        cin>>T;
        priority_queue<int> pq;
        int num;
        for(int j=0;j<T;j++)
        {
            cin>>num;
            if(num>0)  pq.push(num);
        }
        int ans=0;        
        while(pq.size()>=3)
        {
            int a=pq.top();pq.pop();
            int b=pq.top();pq.pop();
            int c=pq.top();pq.pop();
            int d=c;
            if(!pq.empty())
            {//这里需要不断消耗第四大的值，使其有机会成为前三大的值
             //90 91 92 93 
             //如果直接减去90
             //则0 1 2 93造成最大的数非常大，其余的数很小，会得不到正确的结果
                d=c-pq.top()+1;
            }
            ans+=d;
            if(a>d)     pq.push(a-d);
            if(b>d)     pq.push(b-d);
            if(c>d)     pq.push(c-d);
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

