## 面试题

### 1. [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

解法1:基于快速排序。

```cpp
int findKthLargest(vector<int>& nums, int k) {
        srand(time(0));
        int l=0,r=nums.size()-1,tar=nums.size()-k;
        while(true)
        {
            int m=partition(nums,l,r);
            if(m==tar)  return nums[m];
            else if(m<tar)  l=m+1;
            else r=m-1;
        }
        return -1;
    }
private:
    int partition(vector<int> &a,int l,int r)
    {
        int k=rand()%(r-l+1)+l;
        int x=a[k];
        swap(a[k],a[r]);
        int i=l-1,j=r;
        while(i<j)
        {
            do i++; while(i<j && a[i]<x);
            do j--; while(i<j && a[j]>x);
            if(i<j) swap(a[i],a[j]);
        }
        swap(a[i],a[r]);
        return i;
    }
```

解法2：利用优先队列，小顶堆。动态维护K个最大的数。

```cpp
int findKthLargest(vector<int>& nums, int k) 
    {
        priority_queue<int,vector<int>,greater<int>> pq;
        for(auto & i:nums)
        {
            if(pq.size()<k)
            {
                pq.push(i);
            }
            else if(pq.size()==k)
            {
                if(pq.top()<i)
                {
                    pq.pop();
                    pq.push(i);
                }
            }
        }
        return pq.top();
    }
```



### 2. [求一个数组中和为sum的方法数](https://blog.csdn.net/guaiguaihenguai/article/details/81842120)

解法：动态规划。类似于背包问题。

```cpp
#include <iostream>
using namespace std;
#include <vector>
int main()
{
    int n,sum;
    cin>>n>>sum;
    vector<long> v(n);
    for(int i = 0;i<n;i++)
        cin>>v[i];
    vector<long> s(sum+1,0);
    s[0] = 1;
    vector<vector<long> > res(n+1,s);
    
    for(int i = 1;i<=n;i++)
    {
        for(int j = 1;j<=sum;j++)
        {
            if(j >= v[i-1])
                res[i][j] = res[i-1][j]+res[i-1][j-v[i-1]];
            else
                res[i][j] = res[i-1][j];
        }
    }
    cout<<res[n][sum]<<endl;
    return 0;
}
```



### 3. [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)[概率大]

```cpp
//解法：哈希+双向链表。队首插入最新的元素，队首为旧元素。当容量超过内存时，优先删除链表尾部的元素。
```

```cpp
//注意,容量可能设置为0，这时需要在put之前进行判断,然后选择continue
LRUCache(int capacity) {
        cap=capacity;
    }
    int get(int key) {
        auto it=m.find(key);
        if(it==m.end()) return -1;
        int val=it->second->second;
        l.erase(it->second);
        l.push_front({key,val});
        m[key]=l.begin();
        return val;
    }
    void put(int key, int value) {
        auto it=m.find(key);
        if(it!=m.end())
        {
            l.erase(it->second);
            m.erase(it);
        }
        l.push_front({key,value});
        m[key]=l.begin();
        if(l.size()>cap)
        {
            int val=l.back().first;
            m.erase(val);
            l.pop_back();
        }
    }
private:
    unordered_map<int,list<pair<int,int>>::iterator> m;
    list<pair<int,int>> l;
    int cap;
```

### 4. [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

解法：排序+双指针+剪枝。

```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int N=nums.size();
        vector<vector<int>> res;
        for(int i=0;i<N-2;i++)
        {
            if(i>0 && nums[i-1]==nums[i]) continue;	//第一处剪枝
            int l=i+1,r=N-1;
            int tar=0-nums[i];
            while(l<r)
            {
                int sum=nums[l]+nums[r];
                if(sum==tar)    
                {
                    res.push_back({nums[i],nums[l],nums[r]});
                    if(nums[l]==nums[r])    break;	//第二处剪枝
                    l++;
                    while(nums[l-1]==nums[l]) l++;	//第三剪枝
                }
                else if(sum<tar)    l++;
                else r--;
            }
        }
        return res;
    }
```

### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

```cpp
vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty() || matrix[0].empty()) return {};
        int N=matrix.size(),M=matrix[0].size();
        int row=0,col=0;
        vector<int> res;
        int cnt=0,num=0;
        while(num<N*M)
        {
            while(col<M-cnt && num<N*M)
            {
                res.push_back(matrix[row][col++]);
                num++;
            }
            col--;row++;
            while(row<N-cnt && num<N*M)
            {
                res.push_back(matrix[row++][col]);
                num++;
            }
            row--;col--;
            while(col>=cnt && num<N*M)
            {
                res.push_back(matrix[row][col--]);
                num++;
            }
            col++;row--;
            while(row>cnt && num<N*M)
            {
                res.push_back(matrix[row--][col]);
                num++;
            }
            row++;col++;
            cnt++;
        }
        return res;
    }
```



### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

```cpp
vector<vector<int>> generateMatrix(int n) {
        if(n==0)    return {};
        if(n==1)    return {{1}};
        vector<vector<int>> res(n,vector<int>(n,0));
        int row=0,col=0,num=0,tar=pow(n,2);
        int cnt=0;
        while(num<=tar)
        {
            while(col<n-cnt && num<=tar)
                res[row][col++]=++num;  //生成上方
            col--;row++;

            if(num==tar)    break;
            while(row<n-cnt&& num<=tar)
                res[row++][col]=++num;  //生成左侧
            row--;col--;

            if(num==tar)    break;
            while(col>=cnt&& num<=tar)
                res[row][col--]=++num;  //生成下方
            col++;row--;
            
            if(num==tar)    break;
            while(row>cnt&& num<=tar)
                res[row--][col]=++num;  //生成右侧
            row++;col++;

            if(num==tar)    break;
            cnt++;  //增加一轮
        }
        return res;
    }
```

### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

解法：利用 `A+B=B+A `的方式。当第二次达到末尾时，退出。

```cpp
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==nullptr || headB==nullptr)    return nullptr;
        ListNode *pA=headA,*pB=headB;
        bool flag=false;    //是否使用第一次的标志
        while(pA!=nullptr && pB!=nullptr && pA!=pB)
        {
            if(pA->next==nullptr && flag==false)
                pA=headB,flag=true;//没使用，则使用
            else if(pA->next==nullptr && flag==true)
                break;//使用了，退出
            else if(pA->next!=nullptr)
                pA=pA->next;
            pB=pB->next==nullptr?headA:pB->next;
        }
        if(pA==pB)  return pA;
        return nullptr;
    }
```

### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

解法：利用快慢指针。

```cpp
bool hasCycle(ListNode *head) {
        if(head==nullptr)   return false;
        ListNode * fast=head,*slow=head;
        while(slow!=nullptr && fast!=nullptr)
        {
            slow=slow->next;
            fast=fast->next;
            if(fast==nullptr || fast->next==nullptr)  return false;
            fast=fast->next;
            if(fast==slow)  return true;
        }
        return false;
    }
```

### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

![image-20200819100306639](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200819100306639.png)

相遇之后，慢指针继续从相遇点开始前进。另外一个指针从起点开始前进，当两者相遇时，即为环的起点。

```cpp
ListNode* detectCycle(ListNode *head) {
        if(head==nullptr)   return nullptr;
        ListNode *slow=head,*fast=head;
        while(slow!=nullptr && fast!=nullptr)
        {
            slow=slow->next;
            fast=fast->next;
            if(fast==nullptr || fast->next==nullptr)    return nullptr;
            fast=fast->next;
            if(fast==slow)  break;
        }
        if(slow==nullptr || fast==nullptr)
            return nullptr;
        ListNode *st=head;
        while(st!=slow)
        {
            st=st->next;
            slow=slow->next;
        }
        return slow;
    }
```









